# File Header (512 Bytes)

The Header is the "Root" of the file. It is a fixed-size block that contains global metadata, format flags, and the byte offsets + byte lengths required to navigate to all other sections.

| Offset | Size | Variable Name                     | Type    | Description                                                 |
| :----- | :--- | :-------------------------------- | :------ | :---------------------------------------------------------- |
| 0      | 4    | `file_signature`                  | ASCII   | Signature: **"B000"**.                                      |
| 4      | 1    | `endianness_flag`                 | u8      | 0 = Little Endian, 1 = Big Endian.                          |
| 5      | 3    | `reserved`                        | u8[3]   | Reserved (0).                                               |
| 8      | 8    | `off_spec_entries`                | u64     | Byte offset to Section A (Spectrum Entries).                |
| 16     | 8    | `len_spec_entries`                | u64     | Byte length of Section A.                                   |
| 24     | 8    | `off_spec_arrayrefs`              | u64     | Byte offset to Section A1 (Spectrum ArrayRef).              |
| 32     | 8    | `len_spec_arrayrefs`              | u64     | Byte length of Section A1.                                  |
| 40     | 8    | `off_chrom_entries`               | u64     | Byte offset to Section B (Chromatogram Entries).            |
| 48     | 8    | `len_chrom_entries`               | u64     | Byte length of Section B.                                   |
| 56     | 8    | `off_chrom_arrayrefs`             | u64     | Byte offset to Section B1 (Chromatogram ArrayRef).          |
| 64     | 8    | `len_chrom_arrayrefs`             | u64     | Byte length of Section B1.                                  |
| 72     | 8    | `off_spec_meta`                   | u64     | Byte offset to Section C (Spectrum Metadata).               |
| 80     | 8    | `len_spec_meta`                   | u64     | On-disk byte length of Section C.                           |
| 88     | 8    | `off_chrom_meta`                  | u64     | Byte offset to Section D (Chromatogram Metadata).           |
| 96     | 8    | `len_chrom_meta`                  | u64     | On-disk byte length of Section D.                           |
| 104    | 8    | `off_global_meta`                 | u64     | Byte offset to Section E (Global Metadata).                 |
| 112    | 8    | `len_global_meta`                 | u64     | On-disk byte length of Section E.                           |
| 120    | 8    | `off_container_spect`             | u64     | Byte offset to the Spectrum container.                      |
| 128    | 8    | `len_container_spect`             | u64     | Byte length of the Spectrum container.                      |
| 136    | 8    | `off_container_chrom`             | u64     | Byte offset to the Chrom container.                         |
| 144    | 8    | `len_container_chrom`             | u64     | Byte length of the Chrom container.                         |
| 152    | 4    | `block_count_spect`               | u32     | Number of BlockDirectory entries in the Spectrum container. |
| 156    | 4    | `block_count_chrom`               | u32     | Number of BlockDirectory entries in the Chrom container.    |
| 160    | 4    | `spectrum_count`                  | u32     | Total number of spectra stored in the file.                 |
| 164    | 4    | `chrom_count`                     | u32     | Total number of chromatograms stored.                       |
| 168    | 4    | `spec_meta_count`                 | u32     | Total metadata rows for spectra.                            |
| 172    | 4    | `spec_meta_num_count`             | u32     | Total numeric values in spectrum metadata pool.             |
| 176    | 4    | `spec_meta_str_count`             | u32     | Total string values in spectrum metadata pool.              |
| 180    | 4    | `chrom_meta_count`                | u32     | Total metadata rows for chromatograms.                      |
| 184    | 4    | `chrom_meta_num_count`            | u32     | Total numeric values in chromatogram metadata pool.         |
| 188    | 4    | `chrom_meta_str_count`            | u32     | Total string values in chromatogram metadata pool.          |
| 192    | 4    | `global_meta_count`               | u32     | Total metadata rows for global metadata.                    |
| 196    | 4    | `global_meta_num_count`           | u32     | Total numeric values in global metadata pool.               |
| 200    | 4    | `global_meta_str_count`           | u32     | Total string values in global metadata pool.                |
| 204    | 4    | `spect_array_count`               | u32     | Number of array types used by Section A1 `array_type`.      |
| 208    | 4    | `chrom_array_count`               | u32     | Number of array types used by Section B1 `array_type`.      |
| 212    | 4    | `reserved`                        | u8[4]   | Reserved (0).                                               |
| 216    | 8    | `target_block_uncompressed_bytes` | u64     | Target uncompressed bytes per block.                        |
| 224    | 1    | `compression_codec`               | u8      | 0 = none, 1 = zstd.                                         |
| 225    | 1    | `compression_level`               | u8      | Codec level (e.g. 0–21 for zstd).                           |
| 226    | 1    | `array_filter`                    | u8      | 0 = none, 1 = byte shuffle.                                 |
| 227    | 1    | `reserved`                        | u8      | Reserved (0).                                               |
| 228    | 4    | `reserved`                        | u8[4]   | Reserved (0).                                               |
| 232    | 8    | `spec_meta_uncompressed_bytes`    | u64     | Uncompressed byte size of Section C after decompression.    |
| 240    | 8    | `chrom_meta_uncompressed_bytes`   | u64     | Uncompressed byte size of Section D after decompression.    |
| 248    | 8    | `global_meta_uncompressed_bytes`  | u64     | Uncompressed byte size of Section E after decompression.    |
| 256    | 256  | `reserved_ext`                    | u8[256] | Reserved (0).                                               |

# Section A: Spectra (32 Bytes)

This section consists of a contiguous array of 32-byte entries. It allows the reader to locate the list of arrays that belong to any spectrum.

| Offset | Size | Name                | Type   | Description                                           |
| :----- | :--- | :------------------ | :----- | :---------------------------------------------------- |
| 0      | 4    | `arr_ref_start`     | u32    | Start index in Section A1 for this spectrum’s arrays. |
| 4      | 4    | `arr_ref_count`     | u32    | Number of arrays for this spectrum (N).               |
| 8      | 4    | `default_array_len` | u32    | `defaultArrayLength` for this spectrum.               |
| 12     | 20   | `reserved`          | u8[20] | Reserved (0).                                         |

# Section A1: Spectrum ArrayRef (32 Bytes)

A contiguous array of 32-byte entries. Each entry represents one array belonging to one spectrum.

| Offset | Size | Name          | Type   | Description                                               |
| :----- | :--- | :------------ | :----- | :-------------------------------------------------------- |
| 0      | 4    | `array_type`  | u32    | Array type identifier (e.g. m/z, intensity, etc.).        |
| 4      | 4    | `block_id`    | u32    | Block index for this array within the Spectrum container. |
| 8      | 8    | `element_off` | u64    | Starting element index within the decompressed block.     |
| 16     | 4    | `element_len` | u32    | Number of elements in this array (`arrayLength`).         |
| 20     | 1    | `dtype`       | u8     | Element type (e.g. f32, f64, i32, i64).                   |
| 21     | 11   | `reserved`    | u8[11] | Reserved (0).                                             |

# Section B: Chromatograms (32 Bytes)

This section consists of a contiguous array of 32-byte entries. It allows the reader to locate the list of arrays that belong to any chromatogram.

| Offset | Size | Name                | Type   | Description                                               |
| :----- | :--- | :------------------ | :----- | :-------------------------------------------------------- |
| 0      | 4    | `arr_ref_start`     | u32    | Start index in Section B1 for this chromatogram’s arrays. |
| 4      | 4    | `arr_ref_count`     | u32    | Number of arrays for this chromatogram (N).               |
| 8      | 4    | `default_array_len` | u32    | `defaultArrayLength` for this chromatogram.               |
| 12     | 20   | `reserved`          | u8[20] | Reserved (0).                                             |

# Section B1: Chromatogram ArrayRef (32 Bytes)

A contiguous array of 32-byte entries. Each entry represents one array belonging to one chromatogram.

| Offset | Size | Name          | Type   | Description                                            |
| :----- | :--- | :------------ | :----- | :----------------------------------------------------- |
| 0      | 4    | `array_type`  | u32    | Array type identifier (e.g. time, intensity, etc.).    |
| 4      | 4    | `block_id`    | u32    | Block index for this array within the Chrom container. |
| 8      | 8    | `element_off` | u64    | Starting element index within the decompressed block.  |
| 16     | 4    | `element_len` | u32    | Number of elements in this array (`arrayLength`).      |
| 20     | 1    | `dtype`       | u8     | Element type (e.g. f32, f64, i32, i64).                |
| 21     | 11   | `reserved`    | u8[11] | Reserved (0).                                          |

# Section C & D: Metadata (Spectra and Chromatograms)

Sections C and D share an identical structure and logic, using a Columnar Storage model to store property-value pairs (CV Parameters). Section C is dedicated to Spectrum metadata, while Section D is dedicated to Chromatogram metadata.

Instead of storing metadata as objects, the format flattens all properties into parallel arrays. Each individual spectrum or chromatogram points to a specific range of indices within these columns to resolve its unique properties.

### Parallel Column Arrays

| Variable Name | Type  | Description                                                                                                                                                                        |
| :------------ | :---- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`CI`**      | u32[] | **Contiguous Index**. A "Range Map" defining boundaries. For any item `i`, its properties are <br> stored in the columns between index `CI[i]` and `CI[i+1]`. Size is `count + 1`. |
| `MTI`         | u8[]  | **Metadata Tag ID**. Metadata Tag ID. The tag/context for metadata row `j` using your `TagId` mapping. `255 = Unknown`. Size = `meta_count`.                                       |
| `MOI`         | u32[] | **Metadata Owner ID**. Tag ID.                                                                                                                                                     |
| `MPI`         | u32[] | **Metadata Parent ID**. Parent ID.                                                                                                                                                 |
| `MRI`         | u8[]  | **Metadata Ref ID**. Identifies the ontology (0=MS, 1=UO, 2=NCIT, 3=PEFF, 255=None).                                                                                               |
| `MAN`         | u32[] | **Metadata Accession**. The numeric tail of the CV term (e.g., 1000514 for MS:1000514).                                                                                            |
| `MURI`        | u8[]  | **Metadata Unit Reference**. Reference ID for the property's unit.                                                                                                                 |
| `MUAN`        | u32[] | **Metadata Unit Accession**. Numeric tail of the unit's accession number.                                                                                                          |
| `VK`          | u8[]  | **Value Kind**. Categorizes the value: 0=Numeric (f64), 1=String (UTF-8), 2=None/Empty.                                                                                            |
| `VI`          | u32[] | **Value Index**. Pointer into the value pools (`VN` or `VOFF/VLEN`).                                                                                                               |
| `VN`          | f64[] | **Numeric Pool**. A dense array of all floating-point metadata values.                                                                                                             |
| `VOFF`        | u32[] | **String Offset**. The starting byte position of a string in the `VS` pool.                                                                                                        |
| `VLEN`        | u32[] | **String Length**. The length of the string in bytes.                                                                                                                              |
| `VS`          | u8[]  | **String Pool**. The concatenated UTF-8 byte stream for all string values.                                                                                                         |

Metadata is encoded as tightly-packed columns in the following exact order:

`CI | MOI | MPI | MTI | MRI | MAN | MURI | MUAN | VK | VI | VN | VOFF | VLEN | VS`

### Lengths

For **Section C (Spectrum metadata)**:

- `item_count = spectrum_count`
- `meta_count = spec_meta_count`
- `num_count  = spec_num_count`
- `str_count  = spec_str_count`

For **Section D (Chromatogram metadata)**:

- `item_count = chrom_count`
- `meta_count = chrom_meta_count`
- `num_count  = chrom_num_count`
- `str_count  = chrom_str_count`

The element counts for each column are:

- `CI` has `item_count + 1` elements
- `MRI, MOI, MPI, MTI, MAN, MURI, MUAN, VK, VI` each have `meta_count` elements
- `VN` has `num_count` elements
- `VOFF, VLEN` each have `str_count` elements
- `VS` has `VS_len_bytes` bytes

### Deriving `VS_len_bytes`

If `str_count == 0`, then `VS_len_bytes = 0`. Otherwise:

`VS_len_bytes = max_{j : VK[j] == 1} (VOFF[VI[j]] + VLEN[VI[j]])`.

### Scheme

```text
                                    ONE ITEM
                             _______________________________
                            /                               \
                           CI[i]: [ 100 ]              CI[i] + 1: [ 108 ]
                            |                               |
                            '--------------+----------------'
                                            |
                                (Range of Metadata j)
                                            |
j:  ...     100    101    102    103    104    105    106    107     ...
           ____________________________________________________________________________
VK:        [ 0 ]  [ 1 ]  [ 0 ]  [ 2 ]  [ 0 ]  [ 1 ]  [ 0 ]  [ 1 ]
VI:        [ 0 ]  [ 0 ]  [ 1 ]  [ 0 ]  [ 2 ]  [ 1 ]  [ 3 ]  [ 2 ]
           ____________________________________________________________________________
             |      |      |      |      |      |      |      |
  (j 100, VI 0)     |      |      |      |      |      |      '---(j 107, VI 2)
  (j 101, VI 0)-----'      |      |      |      |      '------------(j 106, VI 3)
  (j 102, VI 1)------------'      |      |      '---------------------(j 105, VI 1)
  (j 103, VI 0)-------------------'      '------------------------------(j 104, VI 2)

POOLS ROUTING:
---------------------------------------------------------------------------------------
IF VK = 0 (Numbers)                    IF VK = 1 (Strings)
VI=0 -> VN[0]: 1.2    (j 100)          VI=0 -> Map[0]: VOFF=0, VLEN=5 ("SPEC1") (j 101)
VI=1 -> VN[1]: 445.1  (j 102)          VI=1 -> Map[1]: VOFF=5, VLEN=3 ("MS1")   (j 105)
VI=2 -> VN[2]: 100.0  (j 104)          VI=2 -> Map[2]: VOFF=8, VLEN=4 ("Scan")  (j 107)
VI=3 -> VN[3]: 2.0    (j 106)          IF VK = 2 (None): Skip Pool (j 103)
---------------------------------------------------------------------------------------

DATA POOLS:
VN (Numbers):  [ 1.2 ]  [ 445.1 ]  [ 100.0 ]  [ 2.0 ]
                 #0        #1         #2        #3

String Map:     (Index 0)         (Index 1)         (Index 2)
VOFF Array:    [    0    ]       [    5    ]       [    8    ]
VLEN Array:    [    5    ]       [    3    ]       [    4    ]
                 |                 |                 |
VS (Bytes): ...[ S ][ P ][ E ][ C ][ 1 ][ M ][ S ][ 1 ][ S ][ c ][ a ][ n ] ...
                \__________0__________/ \______1______/ \________2________/

```

### Data Access Pattern

To resolve metadata for an item at index `i`, the reader performs a **two-step lookup**:

1. **Find the Range**: Query `CI[i]` (start) and `CI[i+1]` (end) to determine the "slice" of metadata rows belonging to that item.
2. **Resolve Values**: Loop through that slice and use the `VK` (Value Kind) to select the correct value pool.

```python
# To retrieve properties for Spectrum i:
start = CI[i]
end = CI[i + 1]

for j in range(start, end):
    # Each 'j' is a property (CVParam)
    tag_id = MTI[j]
    ref_id = MRI[j]
    acc_num = MAN[j]

    if VK[j] == 0:
        # Numeric property
        val = VN[VI[j]]
    elif VK[j] == 1:
        # String property
        val = VS[VOFF[VI[j]] : VOFF[VI[j]] + VLEN[VI[j]]]
```

# Section E: Global Metadata

This section stores high-level, non-sequential information (such as software settings, sample descriptions, and instrument configurations). It consists of two parts: a **General Header** that defines the quantity of global items per category, followed by a **Columnar Storage** block containing the actual properties.

### General Header (32 Bytes)

The first 32 bytes of Section E serve as a blueprint, defining the number of "logical items" within each global category. These categories are processed sequentially by the Contiguous Index (CI).

| Offset | Variable Name            | Type | mzML Equivalent Element             | Description                                    |
| :----- | :----------------------- | :--- | :---------------------------------- | :--------------------------------------------- |
| 0      | `n_file_description`     | u32  | **`<fileDescription>`**             | Info on the run and spectra types.             |
| 4      | `n_ref_param_groups`     | u32  | **`<referenceableParamGroupList>`** | Groups of CV terms referenced as a unit.       |
| 8      | `n_samples`              | u32  | **`<sampleList>`**                  | Data about the biological or chemical analyte. |
| 12     | `n_instrument_configs`   | u32  | **`<instrumentConfigurationList>`** | Hardware and operational configurations.       |
| 16     | `n_software`             | u32  | **`<softwareList>`**                | History of software tools utilized.            |
| 20     | `n_data_processing`      | u32  | **`<dataProcessingList>`**          | History of processing after raw acquisition.   |
| 24     | `n_acquisition_settings` | u32  | **`<acquisitionSettingsList>`**     | Special parameters such as inclusion lists.    |
| 28     | `n_cvs`                  | u32  | **`<cvList>`**                      | Referenced controlled vocabulary info.         |

---

### Columnar Storage

Section E utilizes the same **Parallel Column Array** structure (CI, MRI, MTI, MAN, VK, etc.) defined in Sections C & D.

The total number of items indexed by the `CI` array in this section is the sum of all counts provided in the **General Header**.

# Raw Data containers

Each raw-data region is stored as a **container** made of many **compressed blocks**. The file header fields `off_container_*` / `len_container_*` / `block_count_*` locate the container and its BlockDirectory.

## Container Definitions

| Container (File Region) | Header: Offset Field  | Header: Length Field  | Header: Block Count Field | Decompressed Content                                                                              |
| :---------------------- | :-------------------- | :-------------------- | :------------------------ | :------------------------------------------------------------------------------------------------ |
| **Spectrum container**  | `off_container_spect` | `len_container_spect` | `block_count_spect`       | All decompressed element arrays referenced by Section A1 (m/z, intensity, and any extra arrays).  |
| **Chrom container**     | `off_container_chrom` | `len_container_chrom` | `block_count_chrom`       | All decompressed element arrays referenced by Section B1 (time, intensity, and any extra arrays). |

Each container referenced by `off_container_*` / `len_container_*` is laid out as:

`[BlockDirectory (block_count_* × 32B)] + [CompressedBlockBuffer …]`

Where:

- `directory_start = off_container_*`
- `directory_bytes = block_count_* × 32`
- `compressed_buffer_start = off_container_* + directory_bytes`

`block_id` in Section A1 / Section B1 is an index into this container’s BlockDirectory (0-based).

## Block Directory Entry (32 Bytes)

A contiguous array of 32-byte entries. Each entry describes one compressed block stored inside the container.

| Range  | Name           | Type  | Description                                                                                |
| :----- | :------------- | :---- | :----------------------------------------------------------------------------------------- |
| 0..7   | `comp_off`     | u64   | Byte offset of this block’s compressed bytes, relative to `compressed_buffer_start`.       |
| 8..15  | `comp_bytes`   | u64   | **Compressed byte length** of this block (number of bytes to read starting at `comp_off`). |
| 16..23 | `uncomp_bytes` | u64   | **Uncompressed byte length** produced after decompression (exact output size).             |
| 24..31 | `reserved`     | u8[8] | Reserved (0).                                                                              |
