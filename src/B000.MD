# File Header (192 Bytes)

The Header is the "Root" of the file. It is a fixed-size block that contains global metadata, data format flags, and the byte offsets required to navigate to all other sections.

| Offset | Size | Variable Name            | Type   | Description                                                   |
| :----- | :--- | :----------------------- | :----- | :------------------------------------------------------------ |
| 0      | 4    | `file_signature`         | ASCII  | Signature: **"B000"**.                                        |
| 4      | 1    | `endianness_flag`        | u8     | 0 = Little Endian, 1 = Big Endian.                            |
| 5      | 3    | `reserved_alignment`     | u8[3]  | Reserved                                                      |
| 8      | 8    | `off_spec_index`         | u64    | Byte offset to Section A (Spectrum Index).                    |
| 16     | 8    | `off_chrom_index`        | u64    | Byte offset to Section B (Chromatogram Index).                |
| 24     | 8    | `off_spec_meta`          | u64    | Byte offset to Section C (Spectrum Metadata).                 |
| 32     | 8    | `off_chrom_meta`         | u64    | Byte offset to Section D (Chromatogram Metadata).             |
| 40     | 8    | `off_global_meta`        | u64    | Byte offset to Section E (Global Metadata).                   |
| 48     | 8    | `size_container_spect_x` | u64    | Total byte size of the **Spectrum X container**.              |
| 56     | 8    | `off_container_spect_x`  | u64    | File byte offset to start of the **Spectrum X container**.    |
| 64     | 8    | `size_container_spect_y` | u64    | Total byte size of the **Spectrum Y container**.              |
| 72     | 8    | `off_container_spect_y`  | u64    | File byte offset to start of the **Spectrum Y container**.    |
| 80     | 8    | `size_container_chrom_x` | u64    | Total byte size of the **Chrom X container**.                 |
| 88     | 8    | `off_container_chrom_x`  | u64    | File byte offset to start of the **Chrom X container**.       |
| 96     | 8    | `size_container_chrom_y` | u64    | Total byte size of the **Chrom Y container**.                 |
| 104    | 8    | `off_container_chrom_y`  | u64    | File byte offset to start of the **Chrom Y container**.       |
| 112    | 4    | `spectrum_count`         | u32    | Total number of spectra stored in the file.                   |
| 116    | 4    | `chrom_count`            | u32    | Total number of chromatograms stored.                         |
| 120    | 4    | `spec_meta_count`        | u32    | Total number of CV param entries for all spectra.             |
| 124    | 4    | `spec_num_count`         | u32    | Total number of CV params (numeric) in spectrum metadata.     |
| 128    | 4    | `spec_str_count`         | u32    | Total number of CV params (string) in spectrum metadata.      |
| 132    | 4    | `chrom_meta_count`       | u32    | Total number of CV param entries for all chromatograms.       |
| 136    | 4    | `chrom_num_count`        | u32    | Total number of CV params (numeric) in chromatogram metadata. |
| 140    | 4    | `chrom_str_count`        | u32    | Total number of CV params (string) in chromatogram metadata.  |
| 144    | 4    | `global_meta_count`      | u32    | Total number of CV params entries for global metadata.        |
| 148    | 4    | `global_num_count`       | u32    | Total number of CV params (numeric) in global metadata.       |
| 152    | 4    | `global_str_count`       | u32    | Total number of CV params (string) in global metadata.        |
| 156    | 4    | `block_count_spect_x`    | u32    | Number of compressed blocks in the Spectrum X container.      |
| 160    | 4    | `block_count_spect_y`    | u32    | Number of compressed blocks in the Spectrum Y container.      |
| 164    | 4    | `block_count_chrom_x`    | u32    | Number of compressed blocks in the Chrom X container.         |
| 168    | 4    | `block_count_chrom_y`    | u32    | Number of compressed blocks in the Chrom Y container.         |
| 172    | 1    | `reserved_flags`         | u8     | Reserved                                                      |
| 173    | 1    | `chrom_x_format`         | u8     | Chromatogram Time: 1=f32, 2=f64.                              |
| 174    | 1    | `chrom_y_format`         | u8     | Chromatogram Intensity: 1=f32, 2=f64.                         |
| 175    | 1    | `spect_x_format`         | u8     | Spectrum m/z: 1=f32, 2=f64.                                   |
| 176    | 1    | `spect_y_format`         | u8     | Spectrum Intensity: 1=f32, 2=f64.                             |
| 177    | 1    | `compression_level`      | u8     | Compression level (0-21).                                     |
| 178    | 1    | `array filter`           | u8     | 0 = none, 1 = byte shuffle                                    |
| 179    | 13   | `reserved`               | u8[14] | Reserved                                                      |

# Section A: Spectra (32 Bytes)

This section consists of a contiguous array of 32-byte entries. It allows the reader to jump directly to the binary data of any spectrum without reading the whole file.

| Offset | Size | Name                | Type | Description                                                              |
| :----- | :--- | :------------------ | :--- | :----------------------------------------------------------------------- |
| 0      | 8    | `mz_element_off`    | u64  | Starting element index in the decompressed Spectrum X (m/z) array.       |
| 8      | 8    | `inten_element_off` | u64  | Starting element index in the decompressed Spectrum Y (intensity) array. |
| 16     | 4    | `mz_element_len`    | u32  | Total number of m/z elements in this spectrum.                           |
| 20     | 4    | `inten_element_len` | u32  | Total number of intensity elements in this spectrum.                     |
| 24     | 4    | `mz_block_id`       | u32  | Block ID where this spectrum’s m/z data is stored (Spectrum X).          |
| 28     | 4    | `inten_block_id`    | u32  | Block ID where this spectrum’s intensity data is stored (Spectrum Y).    |

# Section B: Chromatograms (32 Bytes)

Identical in structure to Section A, this section provides random access to chromatogram time and intensity arrays.

| Offset | Size | Name                | Type | Description                                                            |
| :----- | :--- | :------------------ | :--- | :--------------------------------------------------------------------- |
| 0      | 8    | `time_element_off`  | u64  | Starting element index in the decompressed Chrom X (time) array.       |
| 8      | 8    | `inten_element_off` | u64  | Starting element index in the decompressed Chrom Y (intensity) array.  |
| 16     | 4    | `time_element_len`  | u32  | Total number of time elements in this chromatogram.                    |
| 20     | 4    | `inten_element_len` | u32  | Total number of intensity elements in this chromatogram.               |
| 24     | 4    | `time_block_id`     | u32  | Block ID where this chromatogram’s time data is stored (Chrom X).      |
| 28     | 4    | `inten_block_id`    | u32  | Block ID where this chromatogram’s intensity data is stored (Chrom Y). |

# Section C & D: Metadata (Spectra and Chromatograms)

Sections C and D share an identical structure and logic, using a Columnar Storage model to store property-value pairs (CV Parameters). Section C is dedicated to Spectrum metadata, while Section D is dedicated to Chromatogram metadata.

Instead of storing metadata as objects, the format flattens all properties into parallel arrays. Each individual spectrum or chromatogram points to a specific range of indices within these columns to resolve its unique properties.

### Parallel Column Arrays

| Variable Name | Type  | Description                                                                                                                                                                        |
| :------------ | :---- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`CI`**      | u32[] | **Contiguous Index**. A "Range Map" defining boundaries. For any item `i`, its properties are <br> stored in the columns between index `CI[i]` and `CI[i+1]`. Size is `count + 1`. |
| `MRI`         | u8[]  | **Metadata Ref ID**. Identifies the ontology (0=MS, 1=UO, 2=NCIT, 3=PEFF, 255=None).                                                                                               |
| `MAN`         | u32[] | **Metadata Accession**. The numeric tail of the CV term (e.g., 1000514 for MS:1000514).                                                                                            |
| `MURI`        | u8[]  | **Metadata Unit Reference**. Reference ID for the property's unit.                                                                                                                 |
| `MUAN`        | u32[] | **Metadata Unit Accession**. Numeric tail of the unit's accession number.                                                                                                          |
| `VK`          | u8[]  | **Value Kind**. Categorizes the value: 0=Numeric (f64), 1=String (UTF-8), 2=None/Empty.                                                                                            |
| `VI`          | u32[] | **Value Index**. Pointer into the value pools (`VN` or `VOFF/VLEN`).                                                                                                               |
| `VN`          | f64[] | **Numeric Pool**. A dense array of all floating-point metadata values.                                                                                                             |
| `VOFF`        | u32[] | **String Offset**. The starting byte position of a string in the `VS` pool.                                                                                                        |
| `VLEN`        | u32[] | **String Length**. The length of the string in bytes.                                                                                                                              |
| `VS`          | u8[]  | **String Pool**. The concatenated UTF-8 byte stream for all string values.                                                                                                         |

Metadata is encoded as tightly-packed columns in the following exact order:

`CI | MRI | MAN | MURI | MUAN | VK | VI | VN | VOFF | VLEN | VS`

### Lengths

For **Section C (Spectrum metadata)**:

- `item_count = spectrum_count`
- `meta_count = spec_meta_count`
- `num_count  = spec_num_count`
- `str_count  = spec_str_count`

For **Section D (Chromatogram metadata)**:

- `item_count = chrom_count`
- `meta_count = chrom_meta_count`
- `num_count  = chrom_num_count`
- `str_count  = chrom_str_count`

The element counts for each column are:

- `CI` has `item_count + 1` elements
- `MRI, MAN, MURI, MUAN, VK, VI` each have `meta_count` elements
- `VN` has `num_count` elements
- `VOFF, VLEN` each have `str_count` elements
- `VS` has `VS_len_bytes` bytes

### Deriving `VS_len_bytes`

If `str_count == 0`, then `VS_len_bytes = 0`. Otherwise:

`VS_len_bytes = max_{j : VK[j] == 1} (VOFF[VI[j]] + VLEN[VI[j]])`.

### Scheme

```text
                                    ONE ITEM
                             _______________________________
                            /                               \
                           CI[i]: [ 100 ]              CI[i] + 1: [ 108 ]
                            |                               |
                            '--------------+----------------'
                                            |
                                (Range of Metadata j)
                                            |
j:  ...     100    101    102    103    104    105    106    107     ...
           ____________________________________________________________________________
VK:        [ 0 ]  [ 1 ]  [ 0 ]  [ 2 ]  [ 0 ]  [ 1 ]  [ 0 ]  [ 1 ]
VI:        [ 0 ]  [ 0 ]  [ 1 ]  [ 0 ]  [ 2 ]  [ 1 ]  [ 3 ]  [ 2 ]
           ____________________________________________________________________________
             |      |      |      |      |      |      |      |
  (j 100, VI 0)     |      |      |      |      |      |      '---(j 107, VI 2)
  (j 101, VI 0)-----'      |      |      |      |      '------------(j 106, VI 3)
  (j 102, VI 1)------------'      |      |      '---------------------(j 105, VI 1)
  (j 103, VI 0)-------------------'      '------------------------------(j 104, VI 2)

POOLS ROUTING:
---------------------------------------------------------------------------------------
IF VK = 0 (Numbers)                    IF VK = 1 (Strings)
VI=0 -> VN[0]: 1.2    (j 100)          VI=0 -> Map[0]: VOFF=0, VLEN=5 ("SPEC1") (j 101)
VI=1 -> VN[1]: 445.1  (j 102)          VI=1 -> Map[1]: VOFF=5, VLEN=3 ("MS1")   (j 105)
VI=2 -> VN[2]: 100.0  (j 104)          VI=2 -> Map[2]: VOFF=8, VLEN=4 ("Scan")  (j 107)
VI=3 -> VN[3]: 2.0    (j 106)          IF VK = 2 (None): Skip Pool (j 103)
---------------------------------------------------------------------------------------

DATA POOLS:
VN (Numbers):  [ 1.2 ]  [ 445.1 ]  [ 100.0 ]  [ 2.0 ]
                 #0        #1         #2        #3

String Map:     (Index 0)         (Index 1)         (Index 2)
VOFF Array:    [    0    ]       [    5    ]       [    8    ]
VLEN Array:    [    5    ]       [    3    ]       [    4    ]
                 |                 |                 |
VS (Bytes): ...[ S ][ P ][ E ][ C ][ 1 ][ M ][ S ][ 1 ][ S ][ c ][ a ][ n ] ...
                \__________0__________/ \______1______/ \________2________/

```

### Data Access Pattern

To resolve metadata for an item at index `i`, the reader performs a **two-step lookup**:

1. **Find the Range**: Query `CI[i]` (start) and `CI[i+1]` (end) to determine the "slice" of metadata rows belonging to that item.
2. **Resolve Values**: Loop through that slice and use the `VK` (Value Kind) to select the correct value pool.

```python
# To retrieve properties for Spectrum i:
start = CI[i]
end = CI[i + 1]

for j in range(start, end):
    # Each 'j' is a property (CVParam)
    ref_id = MRI[j]
    acc_num = MAN[j]

    if VK[j] == 0:
        # Numeric property
        val = VN[VI[j]]
    elif VK[j] == 1:
        # String property
        val = VS[VOFF[VI[j]] : VOFF[VI[j]] + VLEN[VI[j]]]
```

# Section E: Global Metadata

This section stores high-level, non-sequential information (such as software settings, sample descriptions, and instrument configurations). It consists of two parts: a **General Header** that defines the quantity of global items per category, followed by a **Columnar Storage** block containing the actual properties.

### General Header (32 Bytes)

The first 32 bytes of Section E serve as a blueprint, defining the number of "logical items" within each global category. These categories are processed sequentially by the Contiguous Index (CI).

| Offset | Variable Name            | Type | mzML Equivalent Element             | Description                                    |
| :----- | :----------------------- | :--- | :---------------------------------- | :--------------------------------------------- |
| 0      | `n_file_description`     | u32  | **`<fileDescription>`**             | Info on the run and spectra types.             |
| 4      | `n_ref_param_groups`     | u32  | **`<referenceableParamGroupList>`** | Groups of CV terms referenced as a unit.       |
| 8      | `n_samples`              | u32  | **`<sampleList>`**                  | Data about the biological or chemical analyte. |
| 12     | `n_instrument_configs`   | u32  | **`<instrumentConfigurationList>`** | Hardware and operational configurations.       |
| 16     | `n_software`             | u32  | **`<softwareList>`**                | History of software tools utilized.            |
| 20     | `n_data_processing`      | u32  | **`<dataProcessingList>`**          | History of processing after raw acquisition.   |
| 24     | `n_acquisition_settings` | u32  | **`<acquisitionSettingsList>`**     | Special parameters such as inclusion lists.    |
| 28     | `n_cvs`                  | u32  | **`<cvList>`**                      | Referenced controlled vocabulary info.         |

---

### Columnar Storage

Section E utilizes the same **Parallel Column Array** structure (CI, MRI, MAN, VK, etc.) defined in Sections C & D.

The total number of items indexed by the `CI` array in this section is the sum of all counts provided in the **General Header**.

# Raw Data data containers

Each raw-data blob (`Spectrum X`, `Spectrum Y`, `Chrom X`, `Chrom Y`) is stored as a **container** holding multiple **independent compressed blocks**. The file header fields `off_container_*` / `size_container_*` point to the start and total size of this container.

## Container Definitions

| Container (File Region) | Header: Offset Field    | Header: Size Field       | Header: Block Count Field | Decompressed Content                     |
| :---------------------- | :---------------------- | :----------------------- | :------------------------ | :--------------------------------------- |
| **Spectrum X**          | `off_container_spect_x` | `size_container_spect_x` | `block_count_spect_x`     | Spectrum m/z elements (f32 or f64)       |
| **Spectrum Y**          | `off_container_spect_y` | `size_container_spect_y` | `block_count_spect_y`     | Spectrum intensity elements (f32 or f64) |
| **Chrom X**             | `off_container_chrom_x` | `size_container_chrom_x` | `block_count_chrom_x`     | Chrom time elements (f32 or f64)         |
| **Chrom Y**             | `off_container_chrom_y` | `size_container_chrom_y` | `block_count_chrom_y`     | Chrom intensity elements (f32 or f64)    |

Each container referenced by off*container*_ / size*container*_ is laid out as:

`[BlockDirectory (block_count × 32B)] + [CompressedBlockBuffer …]`

Where:

- `directory_start = off_container_*`

- `directory_bytes = block_count_* × 32`

- `compressed_buffer_start = off_container_* + directory_bytes`

## Block Directory Entry (32 Bytes)

A contiguous array of 32-byte entries. `block_id` indexes this array directly (0-based).

| Range  | Name           | Type  | Description                                                                     |
| :----- | :------------- | :---- | :------------------------------------------------------------------------------ |
| 0..7   | `comp_off`     | u64   | Offset **from `compressed_buffer_start`** (start of the CompressedBlockBuffer). |
| 8..15  | `comp_size`    | u64   | Compressed size in bytes.                                                       |
| 16..23 | `uncomp_bytes` | u64   | Uncompressed size in bytes after Inflate.                                       |
| 24..31 | `reserved`     | u8[8] | Reserved (Set to 0).                                                            |

---
